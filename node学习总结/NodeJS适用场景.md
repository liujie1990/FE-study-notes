### Apache 的多线程高并发模式
优点：支持多线程并发

缺点：阻塞

### 什么是线程
线程是可以独立运行的最小的 CPU 单位，可以在同一个进程里并发运行，共享该进程下的内存地址空间。

当不同的线程需要占用同一个变量时，根据先到先得的原则，先到的线程在运作时，后来的线程只能在旁边等待，也就是加入到了阻塞排队序列。就造成了线程阻塞。

类似场景：银行柜台办理业务

### NodeJS 的异步 I/O 原理
优点：高并发（最重要的优点）、适合 I/O 密集型应用

缺点：

不适合CPU密集型应用（CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致 CPU 时间片不能释放，使得后续 I/O 无法发起）
只支持单核CPU，不能充分利用CPU
可靠性低，一旦代码某个环节崩溃，整个系统都崩溃
原因：单进程、单线程
解决方案：
（1）Nnigx 反向代理，负载均衡，开多个进程，绑定多个端口；
（2）开多个进程监听同一个端口，使用cluster模块
（3）线上使用 PM2 管理进程，出现问题自动重启项目
Debug 不方便，错误没有 stack trace
NodeJS 基于事件循环，每一条 NodeJS 的逻辑写在回调函数里面，回调函数在返回之后异步执行。

NodeJS 不是没有阻塞，而是阻塞不发生在后续回调的流程，而会发生在 NodeJS 本身对逻辑的计算和处理。

NodeJS 它的所有 I/O、网络通信等比较耗时的操作，都可以交给 worker threads 执行再回调，所以很快。但 CPU 的正常操作，它只能自己操作。

类似场景：排队点餐后叫号取餐。

### NodeJS 的应用场景
NodeJS 处理并发的能力强，但处理计算和逻辑的能力反而很弱。

因此，我们把复杂的逻辑运算搬到前端（客户端）完成，而 NodeJS 只需要提供异步 I/O，这样就可以实现对高并发的高性能处理。

### RESTful API
这是 NodeJS 最理想的应用场景，可以处理数万条连接，本身没有太多的逻辑，只需要请求 API，组织数据进行返回即可。

它本质上只是从某个数据库中查找一些值并将它们组成一个响应。

由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的 API 需求。

### 大量 Ajax 请求的应用
实时聊天、客户端逻辑强大的单页 APP，具体的例子比如说：本地化的在线音乐应用，本地化的在线搜索应用，本地化的在线 APP 等。

### Apache 适用场景
Apache 由于其多线程高并发共享内存地址空间的特性，那就意味着如果服务器足够强大，处理器足够高核，Apache 的运作将会非常良好，所以适用于（并发）异步处理相对较少，后台计算量大，后台业务逻辑复杂的应用程序。